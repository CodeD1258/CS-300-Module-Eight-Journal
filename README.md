# CS-300-Module-Eight-Journal
In CS300, the projects typically revolved around applying different data structures to solve real-world problems more efficiently. One of the main problems I worked on involved optimizing search operations for a large dataset by implementing a binary search tree. The challenge was to ensure that data was stored and retrieved quickly while keeping the program scalable as the dataset grew larger.

My approach to solving the problem was all about breaking the task down into smaller components. First, I made sure I understood the specific data I was working with and identified which operations were the most critical (e.g., search vs. insertion). After that, I focused on choosing the appropriate data structure. In this case, a binary search tree made sense due to its efficiency in searching for elements. Understanding the theory behind data structures was crucial because it helped me make smarter decisions. I realized that while an array is simple, it doesn't scale well when you have to deal with frequent insertions and deletions.

One of the biggest roadblocks I encountered was figuring out how to balance the tree after inserting new nodes to ensure optimal performance. At first, it seemed like a small issue, but it quickly became clear that an unbalanced tree could seriously degrade performance. To overcome this, I revisited the algorithm and broke down the logic behind tree rotations, eventually implementing an AVL tree to keep everything balanced.

This project really expanded my approach to designing software. Before, I mostly focused on getting things to work. Now, I pay more attention to how I structure the data and the long-term impact of the choices I make, especially when it comes to performance and scalability. I’ve also gotten better at thinking about edge cases and making sure my code can handle those gracefully.

As for how it changed the way I write code, I’ve definitely become more conscious of maintaining readability and modularity. Instead of writing everything in one long function, I’m now focused on separating concerns and making sure each part of the program is responsible for a single thing. I’ve also learned the importance of testing thoroughly, especially when it comes to data structures, where small bugs can cause major issues down the road.

This project taught me that understanding and using the right data structure can make all the difference in the performance and maintainability of your program. It’s not just about getting the code to work, but getting it to work efficiently and in a way that’s easy to extend or adapt in the future.
